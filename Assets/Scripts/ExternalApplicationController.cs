using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Diagnostics;
using System.IO;
using System.Xml;

public interface IRenderingProcess
{
    string rendererName();

    bool isOwnedFiletype(string filename);

    List<FileInfo> filterOwnWorkspaceFiles(List<FileInfo> filenames);

    Texture loadWorkspacePreview(string filename);
    Process startRendering(string filename);
}

public class InviwoRenderingProcess : IRenderingProcess
{
    public string rendererName()
    {
        return "Inviwo";
    }

    public bool isOwnedFiletype(string filename)
    {
        return filename.EndsWith(".inv");
    }

    public List<FileInfo> filterOwnWorkspaceFiles(List<FileInfo> filenames)
    {
        return filenames.FindAll(f => (isOwnedFiletype(f.FullName)));
    }

    public Texture loadWorkspacePreview(string filename)
    {
        var fileContents = File.ReadAllText(filename);

        string totVal = "";
        XmlDocument xmlDoc = new XmlDocument();
        xmlDoc.Load (new StringReader(fileContents));
        string xmlPathPattern = "//CanvasImage/base64/@content";
        XmlNode canvasNode  = xmlDoc.SelectSingleNode(xmlPathPattern);

        Texture2D tex = new Texture2D(512, 512);
        if (canvasNode != null)
        {
            //Create texture
            byte[] b64_bytes = System.Convert.FromBase64String(canvasNode.Value);
            tex.LoadImage(b64_bytes);
        }

        return tex;
    }

    public Process startRendering(string filename)
    {
        //Start instance
        ProcessStartInfo startInfo = new ProcessStartInfo();
        startInfo.LoadUserProfile = true;
        startInfo.FileName = EnvConstants.InviwoPath;
        startInfo.Arguments = "-n -c -w "+filename;
        return Process.Start(startInfo); // TODO: return only startinfo and somebody else starts renderer?
    }
}

public class MegaMolRenderingProcess : IRenderingProcess
{
    public string rendererName()
    {
        return "MegaMol";
    }

    public bool isOwnedFiletype(string filename)
    {
        return filename.EndsWith(".mmprj");
    }

    public List<FileInfo> filterOwnWorkspaceFiles(List<FileInfo> filenames)
    {
        return filenames.FindAll(f => (isOwnedFiletype(f.FullName)));
    }


    public Texture loadWorkspacePreview(string filename)
    {
        return null;
    }

    public Process startRendering(string filename)
    {
        ProcessStartInfo startInfo = new ProcessStartInfo();
        startInfo.LoadUserProfile = true;
        startInfo.FileName = EnvConstants.MegamolPath;
        startInfo.Arguments = "-p \"" + filename + "\" -i Project_1 inst"; // mmconsole.exe started with arguments for project file generated by MegaMolConfigurator
        return Process.Start(startInfo);
    }
}

public class MintRenderingProcess : IRenderingProcess
{
    public string rendererName()
    {
        return "Mint Rendering";
    }

    public bool isOwnedFiletype(string filename)
    {
        return filename.EndsWith(".exe");
    }

    public List<FileInfo> filterOwnWorkspaceFiles(List<FileInfo> filenames)
    {
        return filenames.FindAll(f => (isOwnedFiletype(f.FullName)));
    }

    public Texture loadWorkspacePreview(string filename)
    {
        return null;
    }

    public Process startRendering(string filename)
    {
        ProcessStartInfo startInfo = new ProcessStartInfo();
        startInfo.LoadUserProfile = true;
        startInfo.FileName = filename;
        startInfo.Arguments = "";
        return Process.Start(startInfo);
    }
}

public class ExternalApplicationController : Singleton<ExternalApplicationController>
{
    private List<Process> m_runningRenderingProcesses = new List<Process>();
    
    // Start is called before the first frame update
    void Start()
    {
        //Check if applications exist
    }

    // Update is called once per frame
    void Update()
    {
        //Keep track of running processes
        foreach(var p in m_runningRenderingProcesses)
            if (p != null && !p.Responding)
            {
                //do what?
            }
    }

    private void OnApplicationQuit()
    {
        this.OnDestroy();
    }

    private void OnDestroy()
    {
        m_runningRenderingProcesses.ForEach(p => p.Kill());
        m_runningRenderingProcesses.Clear();
    }

    public void addRendererInstance(Process proc)
    {
        m_runningRenderingProcesses.Add(proc);
    }

    // TODO: how to close one of the running processes?

    public void closeAllRendererInstances()
    {
        this.OnDestroy();
        // TODO: reset dataset object such that newly created renderers are treated correctly? (i.e. Bbox receiving script waits for new bbox bounds)
    }
}
